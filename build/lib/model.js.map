{"version":3,"sources":["../../lib/model.js"],"names":["require","_","Promise","EntityFactory","Diaspora","Set","Validator","entityPrototypeProperties","findArgs","model","queryFind","options","dataSourceName","ret","isString","isNil","dataSource","getDataSource","makeSet","newEntities","map","dataSourceEntities","entityFactory","dataSourceEntity","set","resolve","makeEntity","newEntity","doDelete","methodName","args","name","doFindUpdate","plural","update","queryComponents","push","compact","value","then","normalizeRemaps","sources","modelDesc","isArrayLike","zipObject","times","length","constant","mapValues","remap","isObject","TypeError","JSON","stringify","Model","reservedPropIntersect","intersection","keys","attributes","Error","hasOwnProperty","sourcesNormalized","sourceNames","modelSources","pick","dataSources","missingSources","difference","v","join","forEach","sourceName","configureCollection","assign","defaultDataSource","first","validator","spawn","source","spawnMany","insert","insertOne","entity","insertMany","find","findMany","updateMany","delete","deleteMany","module","exports"],"mappings":"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","file":"model.js","sourcesContent":["'use strict';\n\nconst {\n\t_, Promise,\n} = require( './dependencies' );\nconst EntityFactory = require( './entityFactory' );\nconst Diaspora = require( './diaspora' );\nconst Set = require( './set' );\nconst Validator = require( './validator' );\n\nconst {\n\tentityPrototypeProperties,\n} = EntityFactory;\n\n/**\n * @module Model\n */\n\n/**\n * Object describing a model.\n *\n * @typedef  {Object} ModelDescription\n * @author gerkin\n * @property {module:Model~SourcesDescriptor}                    sources         - List of sources to use with this model.\n * @property {Object<string, module:Model~AttributesDescriptor>} attributes      - Attributes of the model.\n * @property {Object<string, Function>}                                methods         - Methods to add to entities prototype.\n * @property {Object<string, Function>}                                staticMethods   - Static methods to add to entities.\n * @property {Object<string, Function|Function[]>}                     lifecycleEvents - Events to bind on entities.\n */\n\n/**\n * Object describing the attributes of a {@link Model~Model}.\n *\n * @typedef  {Object} AttributesDescriptor\n * @author gerkin\n * @property {string} [type]           - Expected type of the value. Either `type` or `model` should be defined, or none.\n * @property {string} [model]          - Expected model of the value. Either `type` or `model` should be defined, or none.\n * @property {module:Model~AttributesDescriptor|module:Model~AttributesDescriptor[]} [of] - Description (or array of descriptions) of possible values for this field\n * @property {boolean} [required=false] - Set to `true` to require a value. Even when `true`, empty arrays are allowed. To require at least one element in an array, use the `minLength` property\n * @property {module:Model~CustomValidator} [validate] - Custom validation callback.\n */\n\nconst findArgs = ( model, queryFind = {}, options = {}, dataSourceName ) => {\n\tlet ret;\n\tif ( _.isString( options ) && _.isNil( dataSourceName )) {\n\t\tret = {\n\t\t\tdataSourceName: options,\n\t\t\toptions:        {},\n\t\t};\n\t} else if ( _.isString( queryFind ) && _.isNil( options ) && _.isNil( dataSourceName )) {\n\t\tret = {\n\t\t\tdataSourceName: queryFind,\n\t\t\tqueryFind:      {},\n\t\t\toptions:        {},\n\t\t};\n\t} else {\n\t\tret = {\n\t\t\tqueryFind,\n\t\t\toptions,\n\t\t\tdataSourceName,\n\t\t};\n\t}\n\tret.dataSource = model.getDataSource( ret.dataSourceName );\n\treturn ret;\n};\n\nconst makeSet = model => {\n\treturn dataSourceEntities => {\n\t\tconst newEntities = _.map( dataSourceEntities, dataSourceEntity => new model.entityFactory( dataSourceEntity ));\n\t\tconst set = new Set( model, newEntities );\n\t\treturn Promise.resolve( set );\n\t};\n};\nconst makeEntity = model => {\n\treturn dataSourceEntity => {\n\t\tif ( _.isNil( dataSourceEntity )) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tconst newEntity = new model.entityFactory( dataSourceEntity );\n\t\treturn Promise.resolve( newEntity );\n\t};\n};\n\nconst doDelete = ( methodName, model ) => {\n\treturn ( queryFind = {}, options = {}, dataSourceName ) => {\n\t\t// Sort arguments\n\t\tconst args = findArgs( model, queryFind, options, dataSourceName );\n\t\treturn args.dataSource[methodName]( model.name, args.queryFind, args.options );\n\t};\n};\n\nconst doFindUpdate = ( model, plural, queryFind, options, dataSourceName, update ) => {\n\t// Sort arguments\n\tconst queryComponents = findArgs( model, queryFind, options, dataSourceName );\n\tconst args = _([ model.name, queryComponents.queryFind ]).push( update ).push( queryComponents.options ).compact().value();\n\treturn queryComponents.dataSource[( update ? 'update' : 'find' ) + ( plural ? 'Many' : 'One' )]( ...args )\n\t\t.then(( plural ? makeSet : makeEntity )( model ));\n};\n\nconst normalizeRemaps = modelDesc => {\n\tlet sources = modelDesc.sources;\n\tif ( _.isString( sources )) {\n\t\tsources = {[modelDesc.sources]: true};\n\t} else if ( _.isArrayLike( sources )) {\n\t\tsources = _.zipObject( sources, _.times( sources.length, _.constant({})));\n\t} else {\n\t\tsources = _.mapValues( sources, ( remap, dataSourceName ) => {\n\t\t\tif ( true === remap ) {\n\t\t\t\treturn {};\n\t\t\t} else if ( _.isObject( remap )) {\n\t\t\t\treturn remap;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError( `Datasource \"${ dataSourceName }\" value is invalid: expect \\`true\\` or a remap hash, but have ${ JSON.stringify( remap ) }` );\n\t\t\t}\n\t\t});\n\t}\n\treturn sources;\n};\n\n/**\n * The model class is used to interact with the population of all data of the same type.\n */\nclass Model {\n\t/**\n\t * Create a new Model that is allowed to interact with all entities of data sources tables selected.\n\t *\n\t * @author gerkin\n\t * @param {string}                              name      - Name of the model.\n\t * @param {ModelConfiguration.ModelDescription} modelDesc - Hash representing the configuration of the model.\n\t */\n\tconstructor( name, modelDesc ) {\n\t\t// Check model configuration\n\t\tconst reservedPropIntersect = _.intersection( entityPrototypeProperties, _.keys( modelDesc.attributes ));\n\t\tif ( 0 !== reservedPropIntersect.length ) {\n\t\t\tthrow new Error( `${ JSON.stringify( reservedPropIntersect ) } is/are reserved property names. To match those column names in data source, please use the data source mapper property` );\n\t\t} else if ( !modelDesc.hasOwnProperty( 'sources' ) || !( _.isArrayLike( modelDesc.sources ) || _.isObject( modelDesc.sources ) || _.isString( modelDesc.sources ))) {\n\t\t\tthrow new TypeError( `Expect model sources to be either a string, an array or an object, had ${ JSON.stringify( modelDesc.sources ) }.` );\n\t\t}\n\t\t// Normalize our sources: normalized form is an object with keys corresponding to source name, and key corresponding to remaps\n\t\tconst sourcesNormalized = normalizeRemaps( modelDesc );\n\t\t// List sources required by this model\n\t\tconst sourceNames = _.keys( sourcesNormalized );\n\t\tconst modelSources = _.pick( Diaspora.dataSources, sourceNames );\n\t\tconst missingSources = _.difference( sourceNames, _.keys( modelSources ));\n\t\tif ( 0 !== missingSources.length ) {\n\t\t\tthrow new Error( `Missing data sources ${ missingSources.map( v => `\"${ v }\"` ).join( ', ' ) }` );\n\t\t}\n\n\t\tif ( !_.isObject( modelDesc.attributes )) {\n\t\t\tthrow new TypeError( `Model attributes should be an object, have ${ JSON.stringify( modelDesc.attributes ) }` );\n\t\t}\n\t\t// Now, we are sure that config is valid. We can configure our datasources with model options, and set `this` properties.\n\t\t_.forEach( sourcesNormalized, ( remap, sourceName ) => modelSources[sourceName].configureCollection( name, remap ));\n\t\t_.assign( this, {\n\t\t\tdataSources:       modelSources,\n\t\t\tdefaultDataSource: _( modelSources ).keys().first(),\n\t\t\tname,\n\t\t\tentityFactory:     EntityFactory( name, modelDesc, this ),\n\t\t\tvalidator:         new Validator( modelDesc.attributes ),\n\t\t});\n\t}\n\n\t/**\n\t * Create a new Model that is allowed to interact with all entities of data sources tables selected.\n\t *\n\t * @author gerkin\n\t * @throws  {Error} Thrown if requested source name does not exists.\n\t * @param   {string} [sourceName=Model.defaultDataSource] - Name of the source to get. It corresponds to one of the sources you set in {@link Model#modelDesc}.Sources.\n\t * @returns {Adapters.DiasporaAdapter} Source adapter with requested name.\n\t */\n\tgetDataSource( sourceName ) {\n\t\tif ( _.isNil( sourceName )) {\n\t\t\tsourceName = this.defaultDataSource;\n\t\t} else if ( !this.dataSources.hasOwnProperty( sourceName )) {\n\t\t\tthrow new Error( `Unknown data source \"${ sourceName }\" in model \"${ this.name }\", available are ${ _.keys( this.dataSources ).map( v => `\"${ v }\"` ).join( ', ' ) }` );\n\t\t}\n\t\treturn this.dataSources[sourceName];\n\t}\n\n\t/**\n\t * Create a new *orphan* {@link Entity entity}.\n\t *\n\t * @author gerkin\n\t * @param   {Object} source - Object to copy attributes from.\n\t * @returns {Entity} New *orphan* entity.\n\t */\n\tspawn( source ) {\n\t\tconst newEntity = new this.entityFactory( source );\n\t\treturn newEntity;\n\t}\n\n\t/**\n\t * Create multiple new *orphan* {@link Entity entities}.\n\t *\n\t * @author gerkin\n\t * @param   {Object[]} sources - Array of objects to copy attributes from.\n\t * @returns {Set} Set with new *orphan* entities.\n\t */\n\tspawnMany( sources ) {\n\t\treturn new Set( this, _.map( sources, source => this.spawn( source )));\n\t}\n\n\t/**\n\t * Insert a raw source object in the data store.\n\t *\n\t * @author gerkin\n\t * @param   {Object} source                                   - Object to copy attributes from.\n\t * @param   {string} [dataSourceName=Model.defaultDataSource] - Name of the data source to insert in.\n\t * @returns {Promise} Promise resolved with new *sync* {@link Entity entity}.\n\t */\n\tinsert( source, dataSourceName ) {\n\t\tconst dataSource = this.getDataSource( dataSourceName );\n\t\treturn dataSource.insertOne( this.name, source ).then( entity => {\n\t\t\treturn Promise.resolve( new this.entityFactory( entity ));\n\t\t});\n\t}\n\n\t/**\n\t * Insert multiple raw source objects in the data store.\n\t *\n\t * @author gerkin\n\t * @param   {Object[]} sources                                  - Array of object to copy attributes from.\n\t * @param   {string}   [dataSourceName=Model.defaultDataSource] - Name of the data source to insert in.\n\t * @returns {Promise} Promise resolved with a {@link Set set} containing new *sync* entities.\n\t */\n\tinsertMany( sources, dataSourceName ) {\n\t\tconst dataSource = this.getDataSource( dataSourceName );\n\t\treturn dataSource.insertMany( this.name, sources ).then( makeSet( this ));\n\t}\n\n\t/**\n\t * Retrieve a single entity from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind={}]                           - Query to get desired entity.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entity from.\n\t * @returns {Promise} Promise resolved with the found {@link Entity entity} in *sync* state.\n\t */\n\tfind( queryFind, options, dataSourceName ) {\n\t\treturn doFindUpdate( this, false, queryFind, options, dataSourceName );\n\t}\n\n\t/**\n\t * Retrieve multiple entities from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind={}]                           - Query to get desired entities.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entities from.\n\t * @returns {Promise} Promise resolved with a {@link Set set} of found entities in *sync* state.\n\t */\n\tfindMany( queryFind, options, dataSourceName ) {\n\t\treturn doFindUpdate( this, true, queryFind, options, dataSourceName );\n\t}\n\n\t/**\n\t * Update a single entity from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind={}]                           - Query to get desired entity.\n\t * @param   {Object}                               update                                   - Attributes to update on matched set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entity from.\n\t * @returns {Promise} Promise resolved with the updated {@link Entity entity} in *sync* state.\n\t */\n\tupdate( queryFind, update, options = {}, dataSourceName ) {\n\t\treturn doFindUpdate( this, false, queryFind, options, dataSourceName, update );\n\t}\n\n\t/**\n\t * Update multiple entities from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind={}]                           - Query to get desired entities.\n\t * @param   {Object}                               update                                   - Attributes to update on matched set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entities from.\n\t * @returns {Promise} Promise resolved with the {@link Set set} of found entities in *sync* state.\n\t */\n\tupdateMany( queryFind, update, options = {}, dataSourceName ) {\n\t\treturn doFindUpdate( this, true, queryFind, options, dataSourceName, update );\n\t}\n\n\t/**\n\t * Delete a single entity from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind]                           - Query to get desired entity.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entity from.\n\t * @returns {Promise} Promise resolved with `undefined`.\n\t */\n\tdelete( queryFind, options = {}, dataSourceName ) {\n\t\treturn doDelete( 'deleteOne', this )( queryFind, options, dataSourceName );\n\t}\n\n\t/**\n\t * Delete multiple entities from specified data source that matches provided `queryFind` and `options`.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} [queryFind={}]                           - Query to get desired entities.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}]                             - Options for this query.\n\t * @param   {string}                               [dataSourceName=Model.defaultDataSource] - Name of the data source to get entities from.\n\t * @returns {Promise} Promise resolved with `undefined`.\n\t */\n\tdeleteMany( queryFind = {}, options = {}, dataSourceName ) {\n\t\treturn doDelete( 'deleteMany', this )( queryFind, options, dataSourceName );\n\t}\n}\n\nmodule.exports = Model;\n"]}