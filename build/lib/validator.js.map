{"version":3,"sources":["../../lib/validator.js"],"names":["dependencies","require","Diaspora","EntityValidationError","components","Errors","_","validateWrongType","keys","fieldDesc","value","tester","type","toValidatePath","validateArrayItems","validator","propVal","index","hasOwnProperty","ofArray","castArray","of","subErrors","map","desc","subIndex","check","clone","pushValidationProp","isArray","undefined","pushEntityProp","getProps","get","compact","length","toPlainObject","omitBy","isNil","messageRequired","model","VALIDATIONS","TYPE","string","isString","integer","isInteger","float","isNumber","date","isDate","boolean","isBoolean","object","isObject","deepTest","attributes","assign","mapValues","pv","propName","pushProp","isEmpty","children","array","any","stubTrue","bool","int","str","text","VALIDATION_STEPS","checkCustoms","validationArgs","error","validateFcts","validate","forEach","validateFct","call","checkTypeRequired","typeKeys","intersection","spec","join","required","checkEnum","enum","result","some","enumVal","RegExp","match","JSON","stringify","PRIVATE","Symbol","PathStack","segmentsEntity","segmentsValidation","prop","concat","filter","val","toArray","slice","Validator","modelDesc","_this","entity","checkResults","field","options","defaults","stepsArgs","validationStep","cloneDeep","module","exports"],"mappings":"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","file":"validator.js","sourcesContent":["'use strict';\n\nconst dependencies = require( './dependencies' );\nconst Diaspora = require( './diaspora' );\nconst {EntityValidationError} = Diaspora.components.Errors;\nconst { _ } = dependencies;\n\n/**\n * @module Validator\n */\n\n/**\n * Execute the simple tester and return an error component if it returns falsey.\n *\n * @param   {Function} tester - The test function to invoke.\n * @returns {module:Validator~Checker} Function to execute to validate the type.\n */\nconst validateWrongType = tester => {\n\treturn ( keys, fieldDesc, value ) => {\n\t\tif ( !tester( value )) {\n\t\t\treturn {type: `${ keys.toValidatePath() } expected to be a \"${ fieldDesc.type }\"`};\n\t\t}\n\t};\n};\n\n/**\n * Prepare the check of each items in the array.\n *\n * @param   {module:Validator~Validator} validator - Validator instance that do this call.\n * @param   {Object}                     fieldDesc - Description of the field to check.\n * @param   {module:Validator~PathStack} keys      - Keys so far.\n * @returns {Function} Function to execute to validate array items.\n */\nconst validateArrayItems = ( validator, fieldDesc, keys ) => {\n\treturn ( propVal, index ) => {\n\t\tif ( fieldDesc.hasOwnProperty( 'of' )) {\n\t\t\tconst ofArray = _.castArray( fieldDesc.of );\n\t\t\tconst subErrors = _( ofArray ).map(( desc, subIndex ) => validator.check(\n\t\t\t\tpropVal,\n\t\t\t\tkeys.clone().pushValidationProp( 'of', _.isArray( fieldDesc.of ) ? subIndex : undefined ).pushEntityProp( index ),\n\t\t\t\t{getProps: false}\n\t\t\t));\n\t\t\tif ( !_.isArray( fieldDesc.of )) {\n\t\t\t\treturn subErrors.get( 0 );\n\t\t\t} else if ( subErrors.compact().value().length === ofArray.length ) {\n\t\t\t\treturn subErrors.toPlainObject().omitBy( _.isNil ).value();\n\t\t\t}\n\t\t}\n\t\treturn {};\n\t};\n};\n\nconst messageRequired = ( keys, fieldDesc ) => {\n\treturn `${ keys.toValidatePath() } is a required property of ${ fieldDesc.type ? `type \"${ fieldDesc.type }\"` : `model \"${ fieldDesc.model }\"` }`;\n};\n\n/**\n * A checker is a function that can return an error component with provided standard args.\n *\n * @callback Checker\n * @param   {module:Validator~PathStack} keys      - Pathstack so far.\n * @param   {Object}                     fieldDesc - Description of the field.\n * @param   {Any}                        value     - Value to check.\n * @returns {Object} Error component.\n */\n\n/**\n * Store for validation functions.\n *\n * @type {object}\n * @property {object<string, module:Validator~Checker>} TYPE - Type checkers.\n * @property {module:Validator~Checker} TYPE.string - String type checker.\n * @property {module:Validator~Checker} TYPE.integer - Integer type checker.\n * @property {module:Validator~Checker} TYPE.float - Float type checker.\n * @property {module:Validator~Checker} TYPE.date - Date type checker.\n * @property {module:Validator~Checker} TYPE.object - Object type checker.\n * @property {module:Validator~Checker} TYPE.array - Array type checker.\n * @property {module:Validator~Checker} TYPE.any - Type checker for type 'any'.\n * @property {module:Validator~Checker} TYPE._ - Default function for unhandled type.\n */\nconst VALIDATIONS = {\n\tTYPE: {\n\t\tstring:  validateWrongType( _.isString ),\n\t\tinteger: validateWrongType( _.isInteger ),\n\t\tfloat:   validateWrongType( _.isNumber ),\n\t\tdate:    validateWrongType( _.isDate ),\n\t\tboolean: validateWrongType( _.isBoolean ),\n\t\tobject( keys, fieldDesc, value ) {\n\t\t\tif ( !_.isObject( value )) {\n\t\t\t\treturn {type: `${ keys.toValidatePath() } expected to be a \"${ fieldDesc.type }\"`};\n\t\t\t} else {\n\t\t\t\tconst deepTest = _.isObject(\n\t\t\t\t\tfieldDesc.attributes\n\t\t\t\t) ? _( _.assign({}, fieldDesc.attributes, value )).mapValues(\n\t\t\t\t\t\t( pv, propName ) => {\n\t\t\t\t\t\t\tconst propVal = value[propName];\n\t\t\t\t\t\t\treturn this.check(\n\t\t\t\t\t\t\t\tpropVal,\n\t\t\t\t\t\t\t\tkeys.clone().pushValidationProp( 'attributes' ).pushProp( propName ),\n\t\t\t\t\t\t\t\t{getProps: false}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\t\t.omitBy( _.isEmpty )\n\t\t\t\t\t\t.value() : {};\n\t\t\t\tif ( !_.isEmpty( deepTest )) {\n\t\t\t\t\treturn {children: deepTest};\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tarray( keys, fieldDesc, value ) {\n\t\t\tif ( !_.isArray( value )) {\n\t\t\t\treturn {type: `${ keys.toValidatePath() } expected to be a \"${ fieldDesc.type }\"`};\n\t\t\t} else {\n\t\t\t\tconst deepTest = _.isObject(\n\t\t\t\t\tfieldDesc.of\n\t\t\t\t) ? _( value ).map( validateArrayItems( this, fieldDesc, keys ))\n\t\t\t\t\t\t.omitBy( _.isEmpty )\n\t\t\t\t\t\t.value() : {};\n\t\t\t\tif ( !_.isEmpty( deepTest )) {\n\t\t\t\t\treturn {children: deepTest};\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tany( keys, fieldDesc, value ) {\n\t\t\tif ( !_.stubTrue( value )) {\n\t\t\t\treturn {type: `${ keys.toValidatePath() } expected to be assigned with any type`};\n\t\t\t}\n\t\t},\n\t\t_( keys, fieldDesc ) {\n\t\t\treturn {type: `${ keys.toValidatePath() } requires to be unhandled type \"${ fieldDesc.type }\"`};\n\t\t},\n\t},\n};\n// Add aliases\n_.assign( VALIDATIONS.TYPE, {\n\tbool: VALIDATIONS.TYPE.boolean,\n\tint:  VALIDATIONS.TYPE.integer,\n\tstr:  VALIDATIONS.TYPE.string,\n\ttext: VALIDATIONS.TYPE.string,\n});\n\n/**\n * Standard function that can be used to add steps to the validation process..\n *\n * @callback ValidationStep\n * @param   {module:Validator~ValidationStepsArgs} validationArgs - Object of arguments.\n * @returns {undefined} This function returns nothing.\n */\n\n/**\n * This object can be passed through each validation steps.\n *\n * @typedef  {Object} ValidationStepsArgs\n * @property {Object}                     error     - Error object to extend.\n * @property {Object}                     fieldDesc - Description of the field.\n * @property {module:Validator~PathStack} keys      - Pathstack representing keys so far.\n * @property {*}                          value     - Value to check.\n */\n\n\nconst VALIDATION_STEPS = ([\n\t/**\n\t * Apply the custom `validate` function or function array, if it exists.\n\t *\n\t * @function module:Validator~checkCustoms\n\t * @type {module:Validator~ValidationStep}\n\t * @param   {module:Validator~ValidationStepsArgs} validationArgs - Validation step argument.\n\t * @returns {undefined} This function returns nothing.\n\t */\n\tfunction checkCustoms( validationArgs ) {\n\t\tconst {\n\t\t\terror, fieldDesc, keys, value,\n\t\t} = validationArgs;\n\t\t// It the field has a `validate` property, try to use it\n\t\tconst validateFcts = _( fieldDesc.validate ).castArray().compact();\n\t\tvalidateFcts.forEach( validateFct => {\n\t\t\tif ( !validateFct.call( this, value, fieldDesc )) {\n\t\t\t\terror.validate = `${ keys.toValidatePath() } custom validation failed`;\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Check if the type & the existence matches the `type` & `required` specifications.\n\t *\n\t * @function module:Validator~checkTypeRequired\n\t * @type {module:Validator~ValidationStep}\n\t * @param   {module:Validator~ValidationStepsArgs} validationArgs - Validation step argument.\n\t * @returns {undefined} This function returns nothing.\n\t */\n\tfunction checkTypeRequired( validationArgs ) {\n\t\tconst {\n\t\t\terror, fieldDesc, keys, value,\n\t\t} = validationArgs;\n\t\t// Check the type and the required status\n\t\tconst typeKeys = _.intersection( _.keys( fieldDesc ), [ 'type', 'model' ]);\n\t\tif ( typeKeys.length > 1 ) {\n\t\t\terror.spec =  `${ keys.toValidatePath() } spec can't have multiple keys from ${ typeKeys.join( ',' ) }`;\n\t\t\t// Apply the `required` modifier\n\t\t} else if ( true === fieldDesc.required && _.isNil( value )) {\n\t\t\terror.required = messageRequired( keys, fieldDesc );\n\t\t} else if ( !_.isNil( value )) {\n\t\t\tif ( fieldDesc.hasOwnProperty( 'type' )) {\n\t\t\t\tif ( _.isString( fieldDesc.type )) {\n\t\t\t\t\t_.assign(\n\t\t\t\t\t\terror,\n\t\t\t\t\t\t// Get the validator. Default to unhandled type\n\t\t\t\t\t\t_.get(\n\t\t\t\t\t\t\tVALIDATIONS,\n\t\t\t\t\t\t\t[ 'TYPE', fieldDesc.type ],\n\t\t\t\t\t\t\tVALIDATIONS.TYPE._\n\t\t\t\t\t\t).call( this, keys, fieldDesc, value ));\n\t\t\t\t} else {\n\t\t\t\t\terror.spec =  `${ keys.toValidatePath() } spec \"type\" must be a string`;\n\t\t\t\t}\n\t\t\t} else if ( fieldDesc.hasOwnProperty( 'model' )) {\n\t\t\t\tif ( _.isString( fieldDesc.model )) {\n\t\t\t\t\tconst tester = _.get( VALIDATIONS, [ 'TYPE', fieldDesc.model ], fieldDesc.model._ );\n\t\t\t\t\t_.assign( error, tester.call( this, keys, fieldDesc, value ));\n\t\t\t\t} else {\n\t\t\t\t\terror.spec =  `${ keys.toValidatePath() } spec \"model\" must be a string`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Verify if the value correspond to a value in the `enum` property.\n\t *\n\t * @function module:Validator~checkEnum\n\t * @type {module:Validator~ValidationStep}\n\t * @param   {module:Validator~ValidationStepsArgs} validationArgs - Validation step argument.\n\t * @returns {undefined} This function returns nothing.\n\t */\n\tfunction checkEnum( validationArgs ) {\n\t\tconst {\n\t\t\terror, fieldDesc, keys, value,\n\t\t} = validationArgs;\n\t\t// Check enum values\n\t\tif ( !_.isNil( value ) && !_.isNil( fieldDesc.enum )) {\n\t\t\tconst result = _.some( fieldDesc.enum, enumVal => {\n\t\t\t\tif ( enumVal instanceof RegExp ) {\n\t\t\t\t\treturn null !== value.match( enumVal );\n\t\t\t\t} else {\n\t\t\t\t\treturn value === enumVal;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif ( false === result ) {\n\t\t\t\terror.enum = `${ keys.toValidatePath() } expected to have one of enumerated values \"${ JSON.stringify( fieldDesc.enum ) }\"`;\n\t\t\t}\n\t\t}\n\t},\n]);\n/**\n * Those validation steps are called one after one during the validation of a single field.\n *\n * @const VALIDATION_STEPS\n * @type {module:Validator~ValidationStep[]}\n * @property {module:Validator~checkCustoms}      '0' - Check for `validate` field.\n * @property {module:Validator~checkTypeRequired} '1' - Check for `type` & `required` fields.\n * @property {module:Validator~checkEnum}         '2' - Check for `enum` field.\n */\n\nconst PRIVATE = Symbol( 'PRIVATE' );\n\n/**\n * The PathStack class allows model validation to follow different paths in model description & entity.\n */\nclass PathStack {\n\t/**\n\t * Constructs a pathstack.\n\t *\n\t * @author gerkin\n\t * @param {string[]} [segmentsEntity=[]]     - Keys to follow in entity.\n\t * @param {string[]} [segmentsValidation=[]] - Keys to follow in model description.\n\t */\n\tconstructor( segmentsEntity = [], segmentsValidation = []) {\n\t\t_.assign( this, {\n\t\t\tsegmentsEntity,\n\t\t\tsegmentsValidation,\n\t\t});\n\t}\n\n\t/**\n\t * Add a path segment for entity navigation.\n\t *\n\t * @param   {...string} prop - Properties to add.\n\t * @returns {module:Validator~PathStack} Returns `this`.\n\t */\n\tpushEntityProp( ...prop ) {\n\t\tthis.segmentsEntity = _( this.segmentsEntity ).concat( prop ).filter( _.isNil ).value();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a path segment for model description navigation.\n\t *\n\t * @param   {...string} prop - Properties to add.\n\t * @returns {module:Validator~PathStack} Returns `this`.\n\t */\n\tpushValidationProp( ...prop ) {\n\t\tthis.segmentsValidation = _( this.segmentsValidation ).concat( prop ).filter( val => !_.isNil( val )).value();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a path segment for both entity & model description navigation.\n\t *\n\t * @param   {...string} prop - Properties to add.\n\t * @returns {module:Validator~PathStack} Returns `this`.\n\t */\n\tpushProp( ...prop ) {\n\t\treturn this.pushEntityProp( ...prop ).pushValidationProp( ...prop );\n\t}\n\n\t/**\n\t * Get a string version of entity segments.\n\t *\n\t * @returns {string} String representation of path in entity.\n\t */\n\ttoValidatePath() {\n\t\treturn this.segmentsEntity.join( '.' );\n\t}\n\n\t/**\n\t * Cast this PathStack to its representing arrays.\n\t *\n\t * @returns {Array<Array<string>>} Array of paths. The first path represents the entity segments, second represents model description segments.\n\t */\n\ttoArray() {\n\t\treturn [\n\t\t\tthis.segmentsEntity.slice(),\n\t\t\tthis.segmentsValidation.slice(),\n\t\t];\n\t}\n\n\t/**\n\t * Duplicate this PathStack, detaching its state from the new.\n\t *\n\t * @returns {module:Validator~PathStack} Clone of caller PathStack.\n\t */\n\tclone() {\n\t\treturn new PathStack( ...this.toArray());\n\t}\n}\n\n/**\n * The Validator class is used to check an entity or its fields against a model description.\n */\nclass Validator {\n\t/**\n\t * Construct a Validator configured for the provided model.\n\t *\n\t * @param {ModelConfiguration.AttributesDescriptor} modelDesc - Model description to validate.\n\t */\n\tconstructor( modelDesc ) {\n\t\tconst _this = {modelDesc};\n\t\tthis[PRIVATE] = _this;\n\t}\n\n\t/**\n\t * Check if the value matches the field description provided, thus verify if it is valid.\n\t *\n\t * @author gerkin\n\t * @param   {Object} entity - Entity to check.\n\t * @returns {Error[]} Array of errors.\n\t */\n\tvalidate( entity ) {\n\t\t// Apply method `checkField` on each field described\n\t\tconst checkResults = _( this[PRIVATE].modelDesc )\n\t\t\t.mapValues(( fieldDesc, field ) => this.check( entity[field], new PathStack().pushProp( field ), {getProps: false}))\n\t\t\t.omitBy( _.isEmpty )\n\t\t\t.value();\n\t\tif ( !_.isNil( checkResults ) && !_.isEmpty( checkResults )) {\n\t\t\tthrow new EntityValidationError( checkResults, 'Validation failed' );\n\t\t}\n\t}\n\n\t/**\n\t * Check if the value matches the field description provided, thus verify if it is valid.\n\t *\n\t * @author gerkin\n\t * @param   {Any}                        value                  - Value to check.\n\t * @param   {module:Validator~PathStack} keys                   - Pathstack representing path to this validation.\n\t * @param   {Object}                     [options=(})]          - Hash of options.\n\t * @param   {boolean}                    options.getProps=false - If `false`, it will use the value directly. If `true`, will try to get the property from value, as if it was an entity.\n\t * @returns {Object} Hash describing errors.\n\t */\n\tcheck( value, keys, options = {}) {\n\t\t_.defaults( options, { getProps: true });\n\t\tif ( !( keys instanceof PathStack )) {\n\t\t\tkeys = new PathStack( keys );\n\t\t}\n\n\t\tconst val = options.getProps ? _.get( value, keys.segmentsEntity ) : value;\n\t\tconst fieldDesc = _.get( this[PRIVATE].modelDesc, keys.segmentsValidation );\n\t\tif ( !_.isObject( fieldDesc )) {\n\t\t\treturn;\n\t\t}\n\t\t_.defaults( fieldDesc, { required: false });\n\n\t\tconst error = {};\n\n\t\tconst stepsArgs = {\n\t\t\terror,\n\t\t\tfieldDesc,\n\t\t\tkeys,\n\t\t\tvalue: val,\n\t\t};\n\n\t\t_.forEach( VALIDATION_STEPS, validationStep => validationStep.call( this, stepsArgs ));\n\n\t\tif ( !_.isEmpty( error )) {\n\t\t\terror.value = value;\n\t\t\treturn error;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the model description provided in constructor.\n\t *\n\t * @readonly\n\t * @type {ModelConfiguration.AttributesDescriptor}\n\t */\n\tget modelDesc() {\n\t\treturn _.cloneDeep( this[PRIVATE].modelDesc );\n\t}\n\n\t/**\n\t * Get the PathStack constructor.\n\t *\n\t * @readonly\n\t * @type {module:Validator~PathStack}\n\t */\n\tstatic get PathStack() {\n\t\treturn PathStack;\n\t}\n}\n\nmodule.exports = Validator;\n"]}