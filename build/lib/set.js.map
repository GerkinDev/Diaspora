{"version":3,"sources":["../../lib/set.js"],"names":["require","_","Promise","Diaspora","Utils","SetValidationError","allEmit","entities","verb","prefix","all","map","entity","index","emit","isArray","wrapEventsAction","sourceName","action","_allEmit","partial","skipEvents","setProxyProps","get","target","prop","match","nth","parseInt","set","val","Error","Set","checkEntitiesFromModel","model","flatten","value","defined","defineEnumerableProperties","length","size","Proxy","forEach","constructor","TypeError","modelName","persist","suffixes","state","validationResults","validate","error","console","logger","errors","compact","call","suffix","fetch","destroy","update","newData","applyUpdateEntity","toObject","module","exports"],"mappings":"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","file":"set.js","sourcesContent":["'use strict';\n\nconst {\n\t_, Promise,\n} = require( './dependencies' );\nconst Diaspora = require( './diaspora' );\nconst Utils = require( './utils' );\nconst SetValidationError = require( './errors/setValidationError' );\n\n/**\n * @module Set\n */\n\n/**\n * Emit events on each entities.\n *\n * @author Gerkin\n * @inner\n * @param   {SequentialEvent[]} entities - Items to iterate over.\n * @param   {string|string[]}   verb     - Verb of the action to emit.\n * @param   {string}            prefix   - Prefix to prepend to the verb.\n * @returns {Promise} Promise resolved once all promises are done.\n */\nconst allEmit = ( entities, verb, prefix ) => Promise.all( entities.map(( entity, index ) => entity.emit( `${ prefix }${ _.isArray( verb ) ? verb[index] : verb }` )));\n\n/**\n * Emit `before` & `after` events around the entity action. `this` must be bound to the calling {@link Set}.\n *\n * @author Gerkin\n * @inner\n * @this Set\n * @param   {string} sourceName    - Name of the data source to interact with.\n * @param   {string} action        - Name of the entity function to apply.\n * @param   {string|string[]} verb - String or array of strings to map for events suffix.\n * @returns {Promise} Promise resolved once events are finished.\n */\nasync function wrapEventsAction( sourceName, action, verb ) {\n\tconst _allEmit = _.partial( allEmit, this.entities, verb );\n\tawait _allEmit( 'before' );\n\tawait Promise.all( this.entities.map( entity => entity[action]( sourceName, {\n\t\tskipEvents: true,\n\t})));\n\tawait _allEmit( 'after' );\n}\n\nconst setProxyProps = {\n\tget( target, prop ) {\n\t\tif ( prop in target ) {\n\t\t\treturn target[prop];\n\t\t} else if ( prop in target.entities ) {\n\t\t\treturn target.entities[prop];\n\t\t} else if ( 'string' === typeof prop && prop.match( /^-?\\d+$/ ) && target.entities.nth( parseInt( prop ))) {\n\t\t\treturn target.entities.nth( parseInt( prop ));\n\t\t}\n\t},\n\tset( target, prop, val ) {\n\t\tif ( 'model' === prop ) {\n\t\t\treturn new Error( 'Can\\'t assign to read-only property \"model\".' );\n\t\t} else if ( 'entities' === prop ) {\n\t\t\tSet.checkEntitiesFromModel( val, target.model );\n\t\t\ttarget.entities = _( val );\n\t\t}\n\t},\n};\n\n/**\n * Collections are used to manage multiple entities at the same time. You may try to use this class as an array.\n */\nclass Set {\n\t/**\n\t * Create a new set, managing provided `entities` that must be generated from provided `model`.\n\t *\n\t * @param {Model}           model    - Model describing entities managed by this set.\n\t * @param {Entity|Entity[]} entities - Entities to manage with this set. Arguments are flattened, so you can provide as many nested arrays as you want.\n\t */\n\tconstructor( model, ...entities ) {\n\t\t// Flatten arguments\n\t\tentities = _( entities ).flatten();\n\t\t// Check if each entity is from the expected model\n\t\tSet.checkEntitiesFromModel( entities.value(), model );\n\n\t\tconst defined = Utils.defineEnumerableProperties( this, {\n\t\t\t/**\n\t\t\t * List entities of this set.\n\t\t\t *\n\t\t\t * @name entities\n\t\t\t * @readonly\n\t\t\t * @memberof Set\n\t\t\t * @instance\n\t\t\t * @type {LodashWrapper<Entity>}\n\t\t\t * @author Gerkin\n\t\t\t */\n\t\t\tentities: entities,\n\t\t\t/**\n\t\t\t * Model that generated this set.\n\t\t\t *\n\t\t\t * @name model\n\t\t\t * @readonly\n\t\t\t * @memberof Set\n\t\t\t * @instance\n\t\t\t * @type {Model}\n\t\t\t * @author Gerkin\n\t\t\t */\n\t\t\tmodel:    model,\n\t\t\t/**\n\t\t\t * Number of entities in this set.\n\t\t\t *\n\t\t\t * @name length\n\t\t\t * @readonly\n\t\t\t * @memberof Set\n\t\t\t * @instance\n\t\t\t * @type {Integer}\n\t\t\t * @author Gerkin\n\t\t\t */\n\t\t\tlength:   {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.entities.size();\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\treturn new Proxy( defined, setProxyProps );\n\t}\n\n\t/**\n\t * Check if all entities in the first argument are from the expected model.\n\t *\n\t * @author gerkin\n\t * @throws {TypeError} Thrown if one of the entity is not from provided `model`.\n\t * @param {Entity[]} entities - Array of entities to check.\n\t * @param {Model}    model    - Model expected to be the source of all entities.\n\t * @returns {undefined} This function does not return anything.\n\t */\n\tstatic checkEntitiesFromModel( entities, model ) {\n\t\tentities.forEach(( entity, index ) => {\n\t\t\tif ( entity.constructor.model !== model ) {\n\t\t\t\tthrow new TypeError( `Provided entity nÂ°${ index } ${ entity } is not from model ${ model } (${ model.modelName })` );\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Persist all entities of this collection.\n\t *\n\t * @fires EntityFactory.Entity#beforeUpdate\n\t * @fires EntityFactory.Entity#afterUpdate\n\t * @author gerkin\n\t * @param {string} sourceName - Data source name to persist in.\n\t * @returns {Promise} Promise resolved once all items are persisted.\n\t * @see {@link EntityFactory.Entity#persist}\n\t */\n\tasync persist( sourceName ) {\n\t\tconst suffixes = this.entities.map( entity => 'orphan' === entity.state ? 'Create' : 'Update' ).value();\n\t\tconst _allEmit = _.partial( allEmit, this.entities );\n\t\tawait _allEmit( 'Persist', 'before' );\n\t\tawait _allEmit( 'Validate', 'before' );\n\t\tconst validationResults = this.entities.map( entity => {\n\t\t\ttry {\n\t\t\t\tentity.validate();\n\t\t\t} catch ( error ) {\n\t\t\t\tconsole.error( error );\n\t\t\t\tDiaspora.logger.error( 'Validation failed:', {\n\t\t\t\t\tentity,\n\t\t\t\t\terror,\n\t\t\t\t});\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}).value();\n\t\tconst errors = _.compact( validationResults ).length;\n\t\tif ( errors > 0 ) {\n\t\t\tthrow new SetValidationError( `Set validation failed for ${ errors } elements (on ${ this.length }): `, validationResults );\n\t\t}\n\t\tawait _allEmit( 'Validate', 'after' );\n\t\tawait wrapEventsAction.call( this, sourceName, 'persist', _.map( suffixes, suffix => `Persist${ suffix }` ));\n\t\tawait _allEmit( 'Persist', 'after' );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Reload all entities of this collection.\n\t *\n\t * @fires EntityFactory.Entity#beforeFind\n\t * @fires EntityFactory.Entity#afterFind\n\t * @author gerkin\n\t * @param {string} sourceName - Data source name to reload entities from.\n\t * @returns {Promise} Promise resolved once all items are reloaded.\n\t * @see {@link EntityFactory.Entity#fetch}\n\t */\n\tasync fetch( sourceName ) {\n\t\tawait wrapEventsAction.call( this, sourceName, 'fetch', 'Fetch' );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Destroy all entities from this collection.\n\t *\n\t * @fires EntityFactory.Entity#beforeDelete\n\t * @fires EntityFactory.Entity#afterDelete\n\t * @author gerkin\n\t * @param {string} sourceName - Name of the data source to delete entities from.\n\t * @returns {Promise} Promise resolved once all items are destroyed.\n\t * @see {@link EntityFactory.Entity#destroy}\n\t */\n\tasync destroy( sourceName ) {\n\t\tawait wrapEventsAction.call( this, sourceName, 'destroy', 'Destroy' );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Update all entities in the set with given object.\n\t *\n\t * @author gerkin\n\t * @param   {Object} newData - Attributes to change in each entity of the collection.\n\t * @returns {Collection} `this`.\n\t */\n\tupdate( newData ) {\n\t\tthis.entities.forEach( entity => {\n\t\t\tUtils.applyUpdateEntity( newData, entity );\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a POJO representation of this set's data.\n\t *\n\t * @author gerkin\n\t * @returns {Object} POJO representation of set & children.\n\t */\n\ttoObject() {\n\t\treturn this.entities.map( entity => entity.toObject()).value();\n\t}\n}\n\nmodule.exports = Set;\n"]}