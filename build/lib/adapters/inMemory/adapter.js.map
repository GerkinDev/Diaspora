{"version":3,"sources":["../../../../lib/adapters/inMemory/adapter.js"],"names":["require","_","Promise","Utils","Diaspora","DiasporaAdapter","components","Adapters","Adapter","InMemoryEntity","InMemoryDiasporaAdapter","state","store","configureCollection","tableName","remaps","ensureCollectionExists","table","hasOwnProperty","items","insertOne","entity","cloneDeep","storeTable","id","generateUUID","setIdHash","push","resolve","classEntity","findOne","queryFind","options","matches","filter","partial","matchEntity","reducedMatches","applyOptionsToSet","maybeCastEntity","first","findMany","maybeCastSet","updateOne","update","then","isNil","found","match","find","applyUpdateEntity","updateMany","length","foundIds","map","indexOf","item","deleteOne","entityToDelete","reject","idHash","name","deleteMany","entitiesIds","entitiesToDelete","get","includes","module","exports"],"mappings":";;;;;;;;;;;;;AAAA;;;;iBAIIA,QAAS,oBAAT,C;MADHC,C,YAAAA,C;MAAGC,O,YAAAA,O;;AAEJ,MAAMC,QAAQH,QAAS,aAAT,CAAd;;AAEA,MAAMI,WAAWJ,QAAS,gBAAT,CAAjB;;AACA,MAAMK,kBAAkBD,SAASE,UAAT,CAAoBC,QAApB,CAA6BC,OAArD;;AACA,MAAMC,iBAAiBT,QAAS,aAAT,CAAvB;AAEA;;;;;;;;MAMMU,uB;;;;;AACL;;;;;AAKA,uCAAc;AAAA;;AACb;;;;;;;;;AASA,0CAAOD,cAAP;AACA,YAAKE,KAAL,GAAa,OAAb;AACA;;;;;;AAKA,YAAKC,KAAL,GAAa,EAAb;AAjBa;AAkBb;AAED;;;;;;;;;;;;WAQAC,mB,gCAAqBC,S,EAAWC,M,EAAS;AACxC,iCAAMF,mBAAN,YAA2BC,SAA3B,EAAsCC,MAAtC;;AACA,WAAKC,sBAAL,CAA6BF,SAA7B;AACA,K,EAED;AACA;;AAEA;;;;;;;;;WAOAE,sB,mCAAwBC,K,EAAQ;AAC/B,UAAK,KAAKL,KAAL,CAAWM,cAAX,CAA2BD,KAA3B,CAAL,EAAyC;AACxC,eAAO,KAAKL,KAAL,CAAWK,KAAX,CAAP;AACA,OAFD,MAEO;AACN,eAAO,KAAKL,KAAL,CAAWK,KAAX,IAAoB;AAC1BE,iBAAO;AADmB,SAA3B;AAGA;AACD,K,EAED;AACA;;AAEA;;;;;;;;;;;WASAC,S,sBAAWH,K,EAAOI,M,EAAS;AAC1BA,eAASpB,EAAEqB,SAAF,CAAaD,MAAb,CAAT;AACA,UAAME,aAAa,KAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;AACAI,aAAOG,EAAP,GAAYrB,MAAMsB,YAAN,EAAZ;AACA,WAAKC,SAAL,CAAgBL,MAAhB;AACAE,iBAAWJ,KAAX,CAAiBQ,IAAjB,CAAuBN,MAAvB;AACA,aAAOnB,QAAQ0B,OAAR,CAAiB,IAAI,KAAKC,WAAT,CAAsBR,MAAtB,EAA8B,IAA9B,CAAjB,CAAP;AACA,K,EAED;AACA;;AAEA;;;;;;;;;;;;WAUAS,O,oBAASb,K,EAAOc,S,EAAWC,O,EAAc;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AACxC,UAAMT,aAAa,KAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;;AACA,UAAMgB,UAAUhC,EAAEiC,MAAF,CAAUX,WAAWJ,KAArB,EAA4BlB,EAAEkC,OAAF,CAAW,KAAKC,WAAhB,EAA6BL,SAA7B,CAA5B,CAAhB;;AACA,UAAMM,iBAAiBlC,MAAMmC,iBAAN,CAAyBL,OAAzB,EAAkCD,OAAlC,CAAvB;AACA,aAAO9B,QAAQ0B,OAAR,CAAiB,KAAKW,eAAL,CAAsBtC,EAAEuC,KAAF,CAASH,cAAT,CAAtB,CAAjB,CAAP;AACA,K;AAED;;;;;;;;;;;;WAUAI,Q,qBAAUxB,K,EAAOc,S,EAAWC,O,EAAc;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AACzC,UAAMT,aAAa,KAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;;AACA,UAAMgB,UAAUhC,EAAEiC,MAAF,CAAUX,WAAWJ,KAArB,EAA4BlB,EAAEkC,OAAF,CAAW,KAAKC,WAAhB,EAA6BL,SAA7B,CAA5B,CAAhB;;AACA,UAAMM,iBAAiBlC,MAAMmC,iBAAN,CAAyBL,OAAzB,EAAkCD,OAAlC,CAAvB;AACA,aAAO9B,QAAQ0B,OAAR,CAAiB,KAAKc,YAAL,CAAmBL,cAAnB,CAAjB,CAAP;AACA,K,EAED;AACA;;AAEA;;;;;;;;;;;;;WAWAM,S,sBAAW1B,K,EAAOc,S,EAAWa,M,EAAQZ,O,EAAc;AAAA;;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AAClD,aAAO,KAAKF,OAAL,CAAcb,KAAd,EAAqBc,SAArB,EAAgCC,OAAhC,EAA0Ca,IAA1C,CAAgD,iBAAS;AAC/D,YAAK,CAAC5C,EAAE6C,KAAF,CAASC,KAAT,CAAN,EAAwB;AACvB,cAAMxB,aAAa,OAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;;AACA,cAAM+B,QAAQ/C,EAAEgD,IAAF,CAAQ1B,WAAWJ,KAAnB,EAA0B;AACvCK,gBAAIuB,MAAMvB;AAD6B,WAA1B,CAAd;;AAGArB,gBAAM+C,iBAAN,CAAyBN,MAAzB,EAAiCI,KAAjC;AACA,iBAAO9C,QAAQ0B,OAAR,CAAiB,OAAKW,eAAL,CAAsBS,KAAtB,CAAjB,CAAP;AACA,SAPD,MAOO;AACN,iBAAO9C,QAAQ0B,OAAR,EAAP;AACA;AACD,OAXM,CAAP;AAYA,K;AAED;;;;;;;;;;;;;WAWAuB,U,uBAAYlC,K,EAAOc,S,EAAWa,M,EAAQZ,O,EAAc;AAAA;;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AACnD,aAAO,KAAKS,QAAL,CAAexB,KAAf,EAAsBc,SAAtB,EAAiCC,OAAjC,EAA2Ca,IAA3C,CAAiD,iBAAS;AAChE,YAAK,CAAC5C,EAAE6C,KAAF,CAASC,KAAT,CAAD,IAAqBA,MAAMK,MAAN,GAAe,CAAzC,EAA6C;AAC5C,cAAM7B,aAAa,OAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;;AACA,cAAMoC,WAAWpD,EAAEqD,GAAF,CAAOP,KAAP,EAAc,IAAd,CAAjB;;AACA,cAAMd,UAAUhC,EAAEiC,MAAF,CAAUX,WAAWJ,KAArB,EAA4B;AAAA,mBAAQ,CAAC,CAAD,KAAOkC,SAASE,OAAT,CAAkBC,KAAKhC,EAAvB,CAAf;AAAA,WAA5B,CAAhB;;AACA,iBAAOtB,QAAQ0B,OAAR,CAAiB,OAAKc,YAAL,CAAmBzC,EAAEqD,GAAF,CAAOrB,OAAP,EAAgB,gBAAQ;AAClE9B,kBAAM+C,iBAAN,CAAyBN,MAAzB,EAAiCY,IAAjC;AACA,mBAAOA,IAAP;AACA,WAH0C,CAAnB,CAAjB,CAAP;AAIA,SARD,MAQO;AACN,iBAAOtD,QAAQ0B,OAAR,CAAgB,EAAhB,CAAP;AACA;AACD,OAZM,CAAP;AAaA,K,EAED;AACA;;AAEA;;;;;;;;;;;;WAUA6B,S,sBAAWxC,K,EAAOc,S,EAAWC,O,EAAc;AAAA;;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AAC1C,UAAMT,aAAa,KAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;AACA,aAAO,KAAKa,OAAL,CAAcb,KAAd,EAAqBc,SAArB,EAAgCC,OAAhC,EAA0Ca,IAA1C,CAAgD,0BAAkB;AACxE,YAAK,CAAC5C,EAAE6C,KAAF,CAASY,cAAT,CAAN,EAAiC;AAChCnC,qBAAWJ,KAAX,GAAmBlB,EAAE0D,MAAF,CAAUpC,WAAWJ,KAArB,EAA4B;AAAA,mBAAUE,OAAOG,EAAP,KAAckC,eAAeE,MAAf,CAAsB,OAAKC,IAA3B,CAAxB;AAAA,WAA5B,CAAnB;AACA;;AACD,eAAO3D,QAAQ0B,OAAR,EAAP;AACA,OALM,CAAP;AAMA,K;AAED;;;;;;;;;;;;WAUAkC,U,uBAAY7C,K,EAAOc,S,EAAWC,O,EAAc;AAAA;;AAAA,UAAdA,OAAc;AAAdA,eAAc,GAAJ,EAAI;AAAA;;AAC3C,UAAMT,aAAa,KAAKP,sBAAL,CAA6BC,KAA7B,CAAnB;AACA,aAAO,KAAKwB,QAAL,CAAexB,KAAf,EAAsBc,SAAtB,EAAiCC,OAAjC,EAA2Ca,IAA3C,CAAiD,4BAAoB;AAC3E,YAAMkB,cAAc9D,EAAEqD,GAAF,CAAOU,gBAAP,EAAyB;AAAA,iBAAU/D,EAAEgE,GAAF,CAAO5C,MAAP,cAA0B,OAAKwC,IAA/B,CAAV;AAAA,SAAzB,CAApB;;AACAtC,mBAAWJ,KAAX,GAAmBlB,EAAE0D,MAAF,CAAUpC,WAAWJ,KAArB,EAA4B,kBAAU;AACxD,iBAAOlB,EAAEiE,QAAF,CAAYH,WAAZ,EAAyB1C,OAAOG,EAAhC,CAAP;AACA,SAFkB,CAAnB;AAGA,eAAOtB,QAAQ0B,OAAR,EAAP;AACA,OANM,CAAP;AAOA,K;;;IAvNoCvB,e;;AA0NtC8D,SAAOC,OAAP,GAAiB1D,uBAAjB","file":"adapter.js","sourcesContent":["'use strict';\n\nconst {\n\t_, Promise,\n} = require( '../../dependencies' );\nconst Utils = require( '../../utils' );\n\nconst Diaspora = require( '../../diaspora' );\nconst DiasporaAdapter = Diaspora.components.Adapters.Adapter;\nconst InMemoryEntity = require( './entity.js' );\n\n/**\n * This class is used to use the memory as a data store. Every data you insert are stored in an array contained by this class. This adapter can be used by both the browser & Node.JS.\n *\n * @extends Adapters.DiasporaAdapter\n * @memberof Adapters\n */\nclass InMemoryDiasporaAdapter extends DiasporaAdapter {\n\t/**\n\t * Create a new instance of in memory adapter.\n\t *\n\t * @author gerkin\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Link to the InMemoryEntity.\n\t\t *\n\t\t * @name classEntity\n\t\t * @type {DataStoreEntities.InMemoryEntity}\n\t\t * @memberof Adapters.InMemoryDiasporaAdapter\n\t\t * @instance\n\t\t * @author Gerkin\n\t\t */\n\t\tsuper( InMemoryEntity );\n\t\tthis.state = 'ready';\n\t\t/**\n\t\t * Plain old javascript object used as data store.\n\t\t *\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.store = {};\n\t}\n\n\t/**\n\t * Create the data store and call {@link Adapters.DiasporaAdapter#configureCollection}.\n\t *\n\t * @author gerkin\n\t * @param   {string} tableName - Name of the table (usually, model name).\n\t * @param   {Object} remaps    - Associative hash that links entity field names with data source field names.\n\t * @returns {undefined} This function does not return anything.\n\t */\n\tconfigureCollection( tableName, remaps ) {\n\t\tsuper.configureCollection( tableName, remaps );\n\t\tthis.ensureCollectionExists( tableName );\n\t}\n\n\t// -----\n\t// ### Utils\n\n\t/**\n\t * Get or create the store hash.\n\t *\n\t * @author gerkin\n\t * @param   {string} table - Name of the table.\n\t * @returns {DataStoreTable} In memory table to use.\n\t */\n\tensureCollectionExists( table ) {\n\t\tif ( this.store.hasOwnProperty( table )) {\n\t\t\treturn this.store[table];\n\t\t} else {\n\t\t\treturn this.store[table] = {\n\t\t\t\titems: [],\n\t\t\t};\n\t\t}\n\t}\n\n\t// -----\n\t// ### Insert\n\n\t/**\n\t * Insert a single entity in the memory store.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#insertOne}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string} table  - Name of the table to insert data in.\n\t * @param   {Object} entity - Hash representing the entity to insert.\n\t * @returns {Promise} Promise resolved once insertion is done. Called with (*{@link InMemoryEntity}* `entity`).\n\t */\n\tinsertOne( table, entity ) {\n\t\tentity = _.cloneDeep( entity );\n\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\tentity.id = Utils.generateUUID();\n\t\tthis.setIdHash( entity );\n\t\tstoreTable.items.push( entity );\n\t\treturn Promise.resolve( new this.classEntity( entity, this ));\n\t}\n\n\t// -----\n\t// ### Find\n\n\t/**\n\t * Retrieve a single entity from the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#findOne}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entity to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link InMemoryEntity}* `entity`).\n\t */\n\tfindOne( table, queryFind, options = {}) {\n\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\tconst matches = _.filter( storeTable.items, _.partial( this.matchEntity, queryFind ));\n\t\tconst reducedMatches = Utils.applyOptionsToSet( matches, options );\n\t\treturn Promise.resolve( this.maybeCastEntity( _.first( reducedMatches )));\n\t}\n\n\t/**\n\t * Retrieve several entities from the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#findMany}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing entities to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once items are found. Called with (*{@link InMemoryEntity}[]* `entities`).\n\t */\n\tfindMany( table, queryFind, options = {}) {\n\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\tconst matches = _.filter( storeTable.items, _.partial( this.matchEntity, queryFind ));\n\t\tconst reducedMatches = Utils.applyOptionsToSet( matches, options );\n\t\treturn Promise.resolve( this.maybeCastSet( reducedMatches ));\n\t}\n\n\t// -----\n\t// ### Update\n\n\t/**\n\t * Update a single entity in the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#updateOne}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to update data in.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entity to find.\n\t * @param   {Object}                               update       - Object properties to set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once update is done. Called with (*{@link InMemoryEntity}* `entity`).\n\t */\n\tupdateOne( table, queryFind, update, options = {}) {\n\t\treturn this.findOne( table, queryFind, options ).then( found => {\n\t\t\tif ( !_.isNil( found )) {\n\t\t\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\t\t\tconst match = _.find( storeTable.items, {\n\t\t\t\t\tid: found.id,\n\t\t\t\t});\n\t\t\t\tUtils.applyUpdateEntity( update, match );\n\t\t\t\treturn Promise.resolve( this.maybeCastEntity( match ));\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Update several entities in the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#updateMany}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to update data in.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing entities to find.\n\t * @param   {Object}                               update       - Object properties to set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once update is done. Called with (*{@link InMemoryEntity}[]* `entities`).\n\t */\n\tupdateMany( table, queryFind, update, options = {}) {\n\t\treturn this.findMany( table, queryFind, options ).then( found => {\n\t\t\tif ( !_.isNil( found ) && found.length > 0 ) {\n\t\t\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\t\t\tconst foundIds = _.map( found, 'id' );\n\t\t\t\tconst matches = _.filter( storeTable.items, item => -1 !== foundIds.indexOf( item.id ));\n\t\t\t\treturn Promise.resolve( this.maybeCastSet( _.map( matches, item => {\n\t\t\t\t\tUtils.applyUpdateEntity( update, item );\n\t\t\t\t\treturn item;\n\t\t\t\t})));\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve([]);\n\t\t\t}\n\t\t});\n\t}\n\n\t// -----\n\t// ### Delete\n\n\t/**\n\t * Delete a single entity from the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#deleteOne}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to delete data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entity to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*undefined*).\n\t */\n\tdeleteOne( table, queryFind, options = {}) {\n\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\treturn this.findOne( table, queryFind, options ).then( entityToDelete => {\n\t\t\tif ( !_.isNil( entityToDelete )) {\n\t\t\t\tstoreTable.items = _.reject( storeTable.items, entity => entity.id === entityToDelete.idHash[this.name]);\n\t\t\t}\n\t\t\treturn Promise.resolve();\n\t\t});\n\t}\n\n\t/**\n\t * Delete several entities from the memory.\n\t *\n\t * @summary This reimplements {@link Adapters.DiasporaAdapter#deleteMany}, modified for in-memory interactions.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to delete data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing entities to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once items are deleted. Called with (*undefined*).\n\t */\n\tdeleteMany( table, queryFind, options = {}) {\n\t\tconst storeTable = this.ensureCollectionExists( table );\n\t\treturn this.findMany( table, queryFind, options ).then( entitiesToDelete => {\n\t\t\tconst entitiesIds = _.map( entitiesToDelete, entity => _.get( entity, `idHash.${ this.name }` ));\n\t\t\tstoreTable.items = _.reject( storeTable.items, entity => {\n\t\t\t\treturn _.includes( entitiesIds, entity.id );\n\t\t\t});\n\t\t\treturn Promise.resolve();\n\t\t});\n\t}\n}\n\nmodule.exports = InMemoryDiasporaAdapter;\n"]}