{"version":3,"sources":["../../../../lib/adapters/base/adapter-utils.js"],"names":["require","_","getNum","fullMatch","sign","val","Infinity","parseInt","validations","type","int","key","isString","isInteger","isFinite","TypeError","rng","range","rangeMatch","match","lower","splice","upper","isInRangeLower","isInRangeUpper","RangeError","validateOption","config","iterateLimit","options","query","foundEntities","foundCount","origSkip","skip","loopFind","isNil","found","Promise","resolve","push","limit","then","remapIO","adapter","tableName","input","direction","filtered","mapValues","value","filter","get","undefined","isFunction","remapType","remaped","mapKeys","module","exports","OPERATORS","$exists","entityVal","targetVal","isUndefined","$equal","$diff","$less","$lessEqual","$greater","$greaterEqual","CANONICAL_OPERATORS","QUERY_OPTIONS_TRANSFORMS","opts","page","hasOwnProperty","ReferenceError"],"mappings":"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","file":"adapter-utils.js","sourcesContent":["'use strict';\n\nconst {_} = require( '../../dependencies' );\n\nconst getNum = ( fullMatch, sign, val ) => {\n\tif ( '∞' === val ) {\n\t\tif ( '-' === sign ) {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn Infinity;\n\t\t}\n\t} else {\n\t\treturn parseInt( fullMatch );\n\t}\n};\n\nconst validations = {\n\ttype: {\n\t\tint( key, val ) {\n\t\t\tif ( _.isString( val )) {\n\t\t\t\tval = parseInt( val );\n\t\t\t}\n\t\t\tif ( !_.isInteger( val ) && isFinite( val )) {\n\t\t\t\tthrow new TypeError( `Expect \"${ key }\" to be an integer`\t );\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\t},\n\trng( key, val, range ) {\n\t\tconst rangeMatch = range.match( /^([[\\]])((-)?(\\d+|∞)),((-)?(\\d+|∞))([[\\]])$/ );\n\t\tif ( rangeMatch ) {\n\t\t\tconst lower = getNum( ...( rangeMatch.splice( 2, 3 )));\n\t\t\tconst upper = getNum( ...( rangeMatch.splice( 2, 3 )));\n\t\t\tconst isInRangeLower = '[' === rangeMatch[1] ? val >= lower : val > lower;\n\t\t\tconst isInRangeUpper = ']' === rangeMatch[2] ? val <= upper : val < upper;\n\t\t\tif ( !( isInRangeLower && isInRangeUpper )) {\n\t\t\t\tthrow new RangeError( `Expect \"${ key }\" to be within ${ range }, have \"${ val }\"` );\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t},\n};\nconst validateOption = ( key, val, config ) => {\n\tif ( validations.type[config.type]) {\n\t\tval = validations.type[config.type]( key, val );\n\t}\n\tif ( config.rng ) {\n\t\tval = validations.rng( key, val, config.rng );\n\t}\n\treturn val;\n};\n\nconst iterateLimit = ( options, query ) => {\n\tconst foundEntities = [];\n\tlet foundCount = 0;\n\tlet origSkip = options.skip;\n\n\t// We are going to loop until we find enough items\n\tconst loopFind = found => {\n\t\t// If the search returned nothing, then just finish the findMany\n\t\tif ( _.isNil( found )) {\n\t\t\treturn Promise.resolve( foundEntities );\n\t\t\t// Else, if this is a value and not the initial `true`, add it to the list\n\t\t} else if ( found !== true ) {\n\t\t\tfoundEntities.push( found );\n\t\t}\n\t\t// If we found enough items, return them\n\t\tif ( foundCount === options.limit ) {\n\t\t\treturn Promise.resolve( foundEntities );\n\t\t}\n\t\toptions.skip = origSkip + foundCount;\n\t\t// Next time we'll skip 1 more item\n\t\tfoundCount++;\n\t\t// Do the query & loop\n\t\treturn query( options ).then( loopFind );\n\t};\n\treturn loopFind;\n};\n\n/**\n * TODO.\n *\n * @author gerkin\n * @see TODO remapping.\n * @param   {Adapters.DiasporaAdapter}  adapter   - Adapter doing the remap.\n * @param   {string}                    tableName - Name of the table for which we remap.\n * @param   {Object}                    query     - Hash representing the entity to remap.\n * @param   {boolean}                   input     - Set to `true` if handling input, `false`to output.\n * @returns {Object} Remapped object.\n */\nconst remapIO = ( adapter, tableName, query, input ) => {\n\tif ( _.isNil( query )) {\n\t\treturn query;\n\t}\n\tconst direction = true === input ? 'input' : 'output';\n\tconst filtered = _.mapValues( query, ( value, key ) => {\n\t\tconst filter = _.get( adapter, [ 'filters', tableName, direction, key ], undefined );\n\t\tif ( _.isFunction( filter )) {\n\t\t\treturn filter( value );\n\t\t}\n\t\treturn value;\n\t});\n\tconst remapType = true === input ? 'normal' : 'inverted';\n\tconst remaped = _.mapKeys( filtered, ( value, key ) => {\n\t\treturn _.get( adapter, [ 'remaps', tableName, remapType, key ], key );\n\t});\n\treturn remaped;\n};\n\nmodule.exports = {\n\tOPERATORS: {\n\t\t$exists:       ( entityVal, targetVal ) => targetVal === !_.isUndefined( entityVal ),\n\t\t$equal:        ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal === targetVal,\n\t\t$diff:         ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal !== targetVal,\n\t\t$less:         ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal < targetVal,\n\t\t$lessEqual:    ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal <= targetVal,\n\t\t$greater:      ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal > targetVal,\n\t\t$greaterEqual: ( entityVal, targetVal ) => !_.isUndefined( entityVal ) && entityVal >= targetVal,\n\t},\n\tCANONICAL_OPERATORS: {\n\t\t'~':  '$exists',\n\t\t'==': '$equal',\n\t\t'!=': '$diff',\n\t\t'<':  '$less',\n\t\t'<=': '$lessEqual',\n\t\t'>':  '$greater',\n\t\t'>=': '$greaterEqual',\n\t},\n\tQUERY_OPTIONS_TRANSFORMS: {\n\t\tlimit( opts ) {\n\t\t\topts.limit = validateOption( 'limit', opts.limit, {\n\t\t\t\ttype: 'int',\n\t\t\t\trng:  '[0,∞]',\n\t\t\t});\n\t\t},\n\t\tskip( opts ) {\n\t\t\topts.skip = validateOption( 'skip', opts.skip, {\n\t\t\t\ttype: 'int',\n\t\t\t\trng:  '[0,∞[',\n\t\t\t});\n\t\t},\n\t\tpage( opts ) {\n\t\t\tif ( !opts.hasOwnProperty( 'limit' )) {\n\t\t\t\tthrow new ReferenceError( 'Usage of \"options.page\" requires \"options.limit\" to be defined.' );\n\t\t\t}\n\t\t\tif ( !isFinite( opts.limit )) {\n\t\t\t\tthrow new RangeError( 'Usage of \"options.page\" requires \"options.limit\" to not be infinite' );\n\t\t\t}\n\t\t\tif ( opts.hasOwnProperty( 'skip' )) {\n\t\t\t\tthrow new ReferenceError( 'Use either \"options.page\" or \"options.skip\"' );\n\t\t\t}\n\t\t\topts.skip = validateOption( 'page', opts.page, {\n\t\t\t\ttype: 'int',\n\t\t\t\trng:  '[0,∞[',\n\t\t\t}) * opts.limit;\n\t\t\tdelete opts.page;\n\t\t},\n\t},\n\t\n\titerateLimit,\n\tremapIO,\n};\n"]}