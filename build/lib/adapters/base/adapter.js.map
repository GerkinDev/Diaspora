{"version":3,"sources":["../../../../lib/adapters/base/adapter.js"],"names":["require","_","Promise","SequentialEvent","OPERATORS","CANONICAL_OPERATORS","QUERY_OPTIONS_TRANSFORMS","iterateLimit","remapIO","DiasporaAdapter","classEntity","state","remaps","remapsInverted","filters","error","undefined","on","err","configureCollection","tableName","normal","inverted","invert","waitReady","resolve","reject","maybeCastEntity","data","isNil","maybeCastSet","datas","map","bind","remapInput","query","remapOutput","setIdHash","entity","propName","idHash","assign","name","matchEntity","matchResult","every","toPairs","key","desc","isObject","entityVal","val","operation","hasOwnProperty","normalizeOptions","opts","cloneDeep","forEach","transform","optionName","defaults","skip","normalizeQuery","originalQuery","options","isString","id","normalizedQuery","mapValues","isUndefined","attrSearch","$exists","Object","$equal","mapKeys","operator","obj","Error","isNumber","isDate","TypeError","JSON","stringify","value","toJSON","pick","insertOne","table","insertMany","then","first","entities","mapSeries","findOne","queryFind","limit","findMany","updateOne","update","updateMany","deleteOne","deleteMany","count","loopFind","found","module","exports"],"mappings":"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","file":"adapter.js","sourcesContent":["'use strict';\n\nconst {\n\t_, Promise, SequentialEvent,\n} = require( '../../dependencies' );\n\n/**\n * @namespace ConstrainedTypes\n * @description Namespace for types with constraints, like <code>[0, Infinity]</code>, <code>]0, Infinity[</code>, etc etc\n */\n\n/**\n * @typedef {Integer} AbsInt0\n * @memberof ConstrainedTypes\n * @description Integer equal or above 0\n */\n\n/**\n * @typedef {Integer} AbsInt\n * @memberof ConstrainedTypes\n * @description Integer above 0\n */\n\n/**\n * @typedef {Integer} AbsIntInf\n * @memberof ConstrainedTypes\n * @description Integer above 0, may be integer\n */\n\n/**\n * @typedef {Integer} AbsIntInf0\n * @memberof ConstrainedTypes\n * @description Integer equal or above 0, may be integer\n */\n\n/**\n * @namespace QueryLanguage\n */\n\n/**\n * @typedef {Object} QueryOptions\n * @description All properties are optional\n * @memberof QueryLanguage\n * @public\n * @instance\n * @author gerkin\n * @property {ConstrainedTypes.AbsInt0} skip=0 Number of items to skip\n * @property {ConstrainedTypes.AbsIntInf0} limit=Infinity Number of items to get\n * @property {ConstrainedTypes.AbsInt0} page To use with {@link QueryOptions.limit `limit`} and without {@link QueryOptions.skip `skip`}. Skips `page` pages of `limit` elements\n * @property {Boolean} remapInput=true Flag indicating if adapter input should be remapped or not. TODO Remapping doc\n * @property {Boolean} remapOutput=true Flag indicating if adapter output should be remapped or not. TODO Remapping doc\n */\n\n/**\n * @typedef {Object} SelectQuery\n * @memberof QueryLanguage\n * @public\n * @instance\n * @author gerkin\n * @property {Any|SelectQueryCondition} * Fields to search. If not providing an object, find items with a property value that equals this value\n */\n\n/**\n * By default, all conditions in a single SelectQueryCondition are combined with an `AND` operator.\n *\n * @typedef {Object} QueryLanguage.SelectQueryCondition\n * @author gerkin\n * @property {Any}                                      $equals       - Match if item value is equal to this. Objects and array are compared deeply. **Alias: `==`**\n * @property {Any}                                      $diff         - Match if item value is different to this. Objects and array are compared deeply. **Alias: `!=`**\n * @property {boolean}                                  $exists       - If `true`, match items where this prop is defined. If `false`, match when prop is null or not set. **Alias: `~`**\n * @property {integer}                                  $less         - Match if item value is less than this. **Alias: `<`**\n * @property {integer}                                  $lessEqual    - Match if item value is less than this or equals to this. **Alias: `<=`**\n * @property {integer}                                  $greater      - Match if item value is greater than this. **Alias: `>`**\n * @property {integer}                                  $greaterEqual - Match if item value is greater than this or equals to this. **Alias: `>=`**\n * @property {QueryLanguage#SelectQueryOrCondition[]}   $or           - Match if *one of* the conditions in the array is true. **Alias: `||`** **NOT IMPLEMENTED YET**\n * @property {QueryLanguage#SelectQueryOrCondition[]}   $and          - Match if *all* the conditions in the array are true. Optional, because several conditions in a single SelectQueryCondition are combined with an `AND` operator. **Alias: `&&`** **NOT IMPLEMENTED YET**\n * @property {QueryLanguage#SelectQueryOrCondition[]}   $xor          - Match if *a single* of the conditions in the array is true. **Alias: `^^`** **NOT IMPLEMENTED YET**\n * @property {QueryLanguage#SelectQueryOrCondition}     $not          - Invert the condition **Alias: `!`** **NOT IMPLEMENTED YET**\n * @property {string}                                   $contains     - On *string*, it will check if query is included in item using GLOB. **NOT IMPLEMENTED YET**\n * @property {QueryLanguage#SelectQueryOrCondition|Any} $contains     - On *array*, it will check if item contains the query. **NOT IMPLEMENTED YET**\n * @property {Any[]}                                    $in           - Check if item value is contained (using deep comparaison) in query. **NOT IMPLEMENTED YET**\n */\n\n/**\n * @typedef {QueryLanguage#SelectQuery|QueryLanguage#SelectQueryCondition} SelectQueryOrCondition\n * @memberof QueryLanguage\n * @public\n * @instance\n * @author gerkin\n */\n\n/**\n * @namespace Adapters\n */\n\n/**\n * @typedef {undefined|null} Nil\n * @memberof Adapters\n * @public\n * @instance\n * @author gerkin\n */\n\n/**\n * @typedef {Adapters.Nil|Object} NilOrObject\n * @memberof Adapters\n * @public\n * @instance\n * @author gerkin\n */\n\nconst {\n\tOPERATORS, CANONICAL_OPERATORS, QUERY_OPTIONS_TRANSFORMS, iterateLimit, remapIO,\n} = require( './adapter-utils' );\n\n/**\n * DiasporaAdapter is the base class of adapters. Adapters are components that are in charge to interact with data sources (files, databases, etc etc) with standardized methods. You should not use this class directly: extend this class and re-implement some methods to build an adapter. See the (upcoming) tutorial section.\n * @extends SequentialEvent\n * @memberof Adapters\n * @author gerkin\n */\nclass DiasporaAdapter extends SequentialEvent {\n\n\t// -----\n\t// ### Initialization\n\n\t/**\n\t * Create a new instance of adapter. This base class should be used by all other adapters.\n\t *\n\t * @public\n\t * @author gerkin\n\t * @param {DataStoreEntities.DataStoreEntity} classEntity - Entity to spawn with this adapter.\n\t */\n\tconstructor( classEntity ) {\n\t\tsuper();\n\t\t/**\n\t\t * Describe current adapter status.\n\t\t *\n\t\t * @type {string}\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.state = 'preparing';\n\t\t/**\n\t\t * Hash to transform entity fields to data store fields.\n\t\t *\n\t\t * @type {Object}\n\t\t * @property {string} * - Data store field associated with this entity field.\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.remaps = {};\n\t\t/**\n\t\t * Hash to transform data store fields to entity fields.\n\t\t *\n\t\t * @type {Object}\n\t\t * @property {string} * - Entity field associated with this data store field.\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.remapsInverted = {};\n\t\t/**\n\t\t * Hash of functions to cast data store values to JSON standard values in entity.\n\t\t *\n\t\t * @type {Object}\n\t\t * @property {Function} * - Filter to execute to get standard JSON value.\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.filters = {};\n\t\t/**\n\t\t * Link to the constructor of the class generated by this adapter.\n\t\t *\n\t\t * @type {DataStoreEntities.DataStoreEntity}\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.classEntity = classEntity;\n\t\t/**\n\t\t * Error triggered by adapter initialization.\n\t\t *\n\t\t * @type {Error}\n\t\t * @author Gerkin\n\t\t */\n\t\tthis.error = undefined;\n\n\t\t// Bind events\n\t\tthis.on( 'ready', () => {\n\t\t\tthis.state = 'ready';\n\t\t}).on( 'error', err => {\n\t\t\tthis.state = 'error';\n\t\t\tthis.error = err;\n\t\t});\n\t}\n\n\t/**\n\t * Saves the remapping table, the reversed remapping table and the filter table in the adapter. Those tables will be used later when manipulating models & entities.\n\t *\n\t * @author gerkin\n\t * @param   {string} tableName    - Name of the table (usually, model name).\n\t * @param   {Object} remaps       - Associative hash that links entity field names with data source field names.\n\t * @param   {Object} [filters={}] - Not used yet...\n\t * @returns {undefined} This function does not return anything.\n\t */\n\tconfigureCollection( tableName, remaps, filters = {}) {\n\t\tthis.remaps[tableName] = {\n\t\t\tnormal:   remaps,\n\t\t\tinverted: _.invert( remaps ),\n\t\t};\n\t\tthis.filters[tableName] = filters;\n\t}\n\n\t// -----\n\t// ### Events\n\n\t/**\n\t * Fired when the adapter is ready to use. You should not try to use the adapter before this event is emitted.\n\t *\n\t * @event Adapters.DiasporaAdapter#ready\n\t * @type {undefined}\n\t * @see {@link Adapters.DiasporaAdapter#waitReady waitReady} Convinience method to wait for state change.\n\t */\n\n\t/**\n\t * Fired if the adapter failed to initialize or changed to `error` state. Called with the triggering `error`.\n\t *\n\t * @event Adapters.DiasporaAdapter#error\n\t * @type {Error}\n\t * @see {@link Adapters.DiasporaAdapter#waitReady waitReady} Convinience method to wait for state change.\n\t */\n\n\t// -----\n\t// ### Utils\n\n\t/**\n\t * Returns a promise resolved once adapter state is ready.\n\t *\n\t * @author gerkin\n\t * @listens Adapters.DiasporaAdapter#error\n\t * @listens Adapters.DiasporaAdapter#ready\n\t * @returns {Promise} Promise resolved when adapter is ready, and rejected if an error occured.\n\t */\n\twaitReady() {\n\t\treturn new Promise(( resolve, reject ) => {\n\t\t\tif ( 'ready' === this.state ) {\n\t\t\t\treturn resolve( this );\n\t\t\t} else if ( 'error' === this.state ) {\n\t\t\t\treturn reject( this.error );\n\t\t\t}\n\t\t\tthis.on( 'ready', () => {\n\t\t\t\treturn resolve( this );\n\t\t\t}).on( 'error', err => {\n\t\t\t\treturn reject( err );\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Cast the provided data to an adapter entity if the data is not nil.\n\t * \n\t * @param   {Adapters.NilOrObject} data - Data to cast to a datastore entity.\n\t * @returns {DataStoreEntities.DataStoreEntity} A class entity, or undefined.\n\t */\n\tmaybeCastEntity( data ) {\n\t\treturn _.isNil( data ) ? undefined : new this.classEntity( data, this );\n\t}\n\n\t/**\n\t * Cast the provided array of datas to adapter entities if the data is not nil. Note that {@link Adapters.Nil nil values} aren't filtered out from the resulting array.\n\t * \n\t * @param   {Adapters.NilOrObject[]|Adapters.Nil} datas - Array of datas to cast to datastore entities.\n\t * @returns {DataStoreEntities.DataStoreEntity[]} An array of class entities, or undefined.\n\t */\n\tmaybeCastSet( datas ) {\n\t\treturn _.isNil( datas ) ? [] : _.map( datas, this.maybeCastEntity.bind( this ));\n\t}\n\n\t/**\n\t * TODO.\n\t *\n\t * @author gerkin\n\t * @see TODO remapping.\n\t * @see {@link Adapters.DiasporaAdapter#remapIO remapIO}\n\t * @param   {string} tableName - Name of the table for which we remap.\n\t * @param   {Object} query     - Hash representing the entity to remap.\n\t * @returns {Object} Remapped object.\n\t */\n\tremapInput( tableName, query ) {\n\t\treturn remapIO( this, tableName, query, true );\n\t}\n\n\t/**\n\t * TODO.\n\t *\n\t * @author gerkin\n\t * @see TODO remapping.\n\t * @see {@link Adapters.DiasporaAdapter#remapIO remapIO}\n\t * @param   {string} tableName - Name of the table for which we remap.\n\t * @param   {Object} query     - Hash representing the entity to remap.\n\t * @returns {Object} Remapped object.\n\t */\n\tremapOutput( tableName, query ) {\n\t\treturn remapIO( this, tableName, query, false );\n\t}\n\n\t/**\n\t * Refresh the `idHash` with current adapter's `id` injected.\n\t *\n\t * @author gerkin\n\t * @param   {Object} entity          - Object containing attributes of the entity.\n\t * @param   {string} [propName='id'] - Name of the `id` field.\n\t * @returns {Object} Modified entity (for chaining).\n\t */\n\tsetIdHash( entity, propName = 'id' ) {\n\t\tentity.idHash = _.assign({}, entity.idHash, {\n\t\t\t[this.name]: entity[propName],\n\t\t});\n\t\treturn entity;\n\t}\n\n\t/**\n\t * Check if provided `entity` is matched by the query. Query must be in its canonical form before using this function.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQuery} query  - Query to match against.\n\t * @param   {Object}                    entity - Entity to test.\n\t * @returns {boolean} Returns `true` if query matches, `false` otherwise.\n\t */\n\tmatchEntity( query, entity ) {\n\t\tconst matchResult = _.every( _.toPairs( query ), ([ key, desc ]) => {\n\t\t\tif ( _.isObject( desc )) {\n\t\t\t\tconst entityVal = entity[key];\n\t\t\t\treturn _.every( desc, ( val, operation ) => {\n\t\t\t\t\tif ( OPERATORS.hasOwnProperty( operation )) {\n\t\t\t\t\t\treturn OPERATORS[operation]( entityVal, val );\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn matchResult;\n\t}\n\n\t/**\n\t * Transform options to their canonical form. This function must be applied before calling adapters' methods.\n\t *\n\t * @author gerkin\n\t * @throws  {TypeError} Thrown if an option does not have an acceptable type.\n\t * @throws  {ReferenceError} Thrown if a required option is not present.\n\t * @throws  {Error} Thrown when there isn't more precise description of the error is available (eg. when conflicts occurs) .\n\t * @param   {Object} [opts={}] - Options to transform.\n\t * @returns {Object} Transformed options (also called `canonical options`).\n\t */\n\tnormalizeOptions( opts = {}) {\n\t\topts = _.cloneDeep( opts );\n\n\t\t_.forEach( QUERY_OPTIONS_TRANSFORMS, ( transform, optionName ) => {\n\t\t\tif ( opts.hasOwnProperty( optionName )) {\n\t\t\t\tQUERY_OPTIONS_TRANSFORMS[optionName]( opts );\n\t\t\t}\n\t\t});\n\n\t\t_.defaults( opts, {\n\t\t\tskip:        0,\n\t\t\tremapInput:  true,\n\t\t\tremapOutput: true,\n\t\t});\n\t\treturn opts;\n\t}\n\n\t/**\n\t * Transform a search query to its canonical form, replacing aliases or shorthands by full query.\n\t *\n\t * @author gerkin\n\t * @param   {QueryLanguage#SelectQueryOrCondition} originalQuery - Query to cast to its canonical form.\n\t * @param   {QueryLanguage#Options}                options       - Options for this query.\n\t * @returns {QueryLanguage#SelectQueryOrCondition} Query in its canonical form.\n\t */\n\tnormalizeQuery( originalQuery, options ) {\n\t\tif ( _.isString( originalQuery )) {\n\t\t\toriginalQuery = { id: originalQuery };\n\t\t}\n\t\tconst normalizedQuery = true === options.remapInput ? _( _.cloneDeep( originalQuery )).mapValues( attrSearch => {\n\t\t\tif ( _.isUndefined( attrSearch )) {\n\t\t\t\treturn { $exists: false };\n\t\t\t} else if ( !( attrSearch instanceof Object )) {\n\t\t\t\treturn { $equal: attrSearch };\n\t\t\t} else {\n\t\t\t\t// Replace operations alias by canonical expressions\n\t\t\t\tattrSearch = _.mapKeys( attrSearch, ( val, operator, obj ) => {\n\t\t\t\t\tif ( CANONICAL_OPERATORS.hasOwnProperty( operator )) {\n\t\t\t\t\t\t// ... check for conflict with canonical operation name...\n\t\t\t\t\t\tif ( obj.hasOwnProperty( CANONICAL_OPERATORS[operator])) {\n\t\t\t\t\t\t\tthrow new Error( `Search can't have both \"${ operator }\" and \"${ CANONICAL_OPERATORS[operator] }\" keys, as they are synonyms` );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn CANONICAL_OPERATORS[operator];\n\t\t\t\t\t}\n\t\t\t\t\treturn operator;\n\t\t\t\t});\n\t\t\t\t// For arithmetic comparison, check if values are numeric (TODO later: support date)\n\t\t\t\t_.forEach([ '$less', '$lessEqual', '$greater', '$greaterEqual' ], operation => {\n\t\t\t\t\tif ( attrSearch.hasOwnProperty( operation ) && !( _.isNumber( attrSearch[operation]) || _.isDate( attrSearch[operation]))) {\n\t\t\t\t\t\tthrow new TypeError( `Expect \"${ operation }\" in ${ JSON.stringify( attrSearch ) } to be a numeric value` );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn attrSearch;\n\t\t\t}\n\t\t}).value() : _.cloneDeep( originalQuery );\n\t\treturn normalizedQuery;\n\t}\n\n\t/**\n\t * Returns a POJO representing the current adapter.\n\t * \n\t * @returns {Object} JSON representation of the adapter.\n\t */\n\ttoJSON() {\n\t\treturn _.pick( this, [ 'state', 'remaps', 'remapsInverted', 'classEntity', 'error' ]);\n\t}\n\n\t// -----\n\t// ### Insert\n\n\t/**\n\t * Insert a single entity in the data store. This function is a default polyfill if the inheriting adapter does not provide `insertOne` itself.\n\t *\n\t * @summary At least one of {@link insertOne} or {@link insertMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string} table  - Name of the table to insert data in.\n\t * @param   {Object} entity - Hash representing the entity to insert.\n\t * @returns {Promise} Promise resolved once insertion is done. Called with (*{@link DataStoreEntity}* entity).\n\t */\n\tinsertOne( table, entity ) {\n\t\treturn this.insertMany( table, [ entity ]).then( entities => Promise.resolve( _.first( entities )));\n\t}\n\n\t/**\n\t * Insert several entities in the data store. This function is a default polyfill if the inheriting adapter does not provide `insertMany` itself.\n\t *\n\t * @summary At least one of {@link insertOne} or {@link insertMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}   table    - Name of the table to insert data in.\n\t * @param   {Object[]} entities - Array of hashs representing the entities to insert.\n\t * @returns {Promise} Promise resolved once insertion is done. Called with (*{@link DataStoreEntity}[]* entities).\n\t */\n\tinsertMany( table, entities ) {\n\t\treturn Promise.mapSeries( entities, entity => this.insertOne( table, entity || {}));\n\t}\n\n\t// -----\n\t// ### Find\n\n\t/**\n\t * Retrieve a single entity from the data store. This function is a default polyfill if the inheriting adapter does not provide `findOne` itself.\n\t *\n\t * @summary At least one of {@link findOne} or {@link findMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entity to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}* `entity`).\n\t */\n\tfindOne( table, queryFind, options = {}) {\n\t\toptions.limit = 1;\n\t\treturn this.findMany( table, queryFind, options ).then( entities => Promise.resolve( _.first( entities )));\n\t}\n\n\t/**\n\t * Retrieve several entities from the data store. This function is a default polyfill if the inheriting adapter does not provide `findMany` itself.\n\t *\n\t * @summary At least one of {@link findOne} or {@link findMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing entities to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}[]* `entities`).\n\t */\n\tfindMany( table, queryFind, options = {}) {\n\t\toptions = this.normalizeOptions( options );\n\t\treturn iterateLimit( options, this.findOne.bind( this, table, queryFind ))( true );\n\t}\n\n\t// -----\n\t// ### Update\n\n\t/**\n\t * Update a single entity from the data store. This function is a default polyfill if the inheriting adapter does not provide `updateOne` itself.\n\t *\n\t * @summary At least one of {@link updateOne} or {@link updateMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entity to find.\n\t * @param   {Object}                               update       - Object properties to set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}* `entity`).\n\t */\n\tupdateOne( table, queryFind, update, options = {}) {\n\t\toptions = this.normalizeOptions( options );\n\t\toptions.limit = 1;\n\t\treturn this.updateMany( table, queryFind, update, options ).then( entities => Promise.resolve( _.first( entities )));\n\t}\n\n\t/**\n\t * Update several entities from the data store. This function is a default polyfill if the inheriting adapter does not provide `updateMany` itself.\n\t *\n\t * @summary At least one of {@link updateOne} or {@link updateMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to retrieve data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing entities to find.\n\t * @param   {Object}                               update       - Object properties to set.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}[]* `entities`).\n\t */\n\tupdateMany( table, queryFind, update, options = {}) {\n\t\toptions = this.normalizeOptions( options );\n\t\treturn iterateLimit( options, this.updateOne.bind( this, table, queryFind, update ))( true );\n\t}\n\n\t// -----\n\t// ### Delete\n\n\t/**\n\t * Delete a single entity from the data store. This function is a default polyfill if the inheriting adapter does not provide `deleteOne` itself.\n\t *\n\t * @summary At least one of {@link deleteOne} or {@link deleteMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to delete data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entities to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}* `entity`).\n\t */\n\tdeleteOne( table, queryFind, options = {}) {\n\t\toptions.limit = 1;\n\t\treturn this.deleteMany( table, queryFind, options );\n\t}\n\n\t/**\n\t * Delete several entities from the data store. This function is a default polyfill if the inheriting adapter does not provide `deleteMany` itself.\n\t *\n\t * @summary At least one of {@link deleteOne} or {@link deleteMany} must be reimplemented by adapter.\n\t * @author gerkin\n\t * @param   {string}                               table        - Name of the table to delete data from.\n\t * @param   {QueryLanguage#SelectQueryOrCondition} queryFind    - Hash representing the entities to find.\n\t * @param   {QueryLanguage#QueryOptions}           [options={}] - Hash of options.\n\t * @returns {Promise} Promise resolved once item is found. Called with (*{@link DataStoreEntity}[]* `entities`).\n\t */\n\tdeleteMany( table, queryFind, options = {}) {\n\t\tlet count = 0;\n\n\t\t// We are going to loop until we find enough items\n\t\tconst loopFind = () => {\n\t\t\t// First, search for the item.\n\t\t\treturn this.findOne( table, queryFind, options ).then( found => {\n\t\t\t\t// If the search returned nothing, then just finish the findMany\n\t\t\t\tif ( _.isNil( found )) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t// Else, if this is a value and not the initial `true`, add it to the list\n\t\t\t\t}\n\t\t\t\t// If we found enough items, return them\n\t\t\t\tif ( count === options.limit ) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t\t// Increase our counter\n\t\t\t\tcount++;\n\t\t\t\t// Do the deletion & loop\n\t\t\t\treturn this.deleteOne( table, queryFind, options ).then( loopFind );\n\t\t\t});\n\t\t};\n\t\treturn loopFind( true );\n\t}\n}\n\nmodule.exports = DiasporaAdapter;\n"]}